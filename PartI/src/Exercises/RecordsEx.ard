\import Records

-- 1. Define the function 'swap' in several ways.

-- Using \cowith and field access.
\func swap {A B : \Type} (p : Pair A B) : Pair B A \cowith
  | fst' => p.snd'
  | snd' => p.fst'

-- Using \new and pattern matching.
\func swap' {A B : \Type} (p : Pair A B) : Pair B A
  | (fst, snd) => \new Pair {
    | fst' => snd
    | snd' => fst
  }

-- Using \new and field access.
\func swap'' {A B : \Type} (p : Pair A B) : Pair B A => \new Pair {
  | fst' => p.snd'
  | snd' => p.fst'
}

-- 2. Prove that 'swap (swap p) = p'.

\func swap-involutive {A B : \Type} (p : Pair A B) : swap (swap p) = p =>
  idp

-- 3. Prove that the type 'PosNat 0' is empty, but the type 'PosNat 1' is not.

\data Empty

\func zero-isNotPos (p : PosNat 0) : Empty =>
  -- How to pattern match on p?
  \case p.p \with {
  }

\func one-isPos : PosNat 1 =>
  \new PosNat 1 tt

-- 4. Define the \record consisting of pairs of coprime natural numbers.
--    Define the type of natural numbers that are coprime with 60.

\import Exercises.BasicsEx (gcd)

\record CoprimeNatPair
  | fst : Nat
  | snd : Nat
  | coprime : gcd fst snd = 1

\func NatCoprimeWith60 => CoprimeNatPair { | snd => 60 }

-- 5. Define the class of monads, which extends the class of functors. Define \instance of this class for 'Maybe'.

\class Monad \extends Functor
  | \infixl 1 >>= {A B : \Type} (F A) (A -> F B) : F B
  --  | >> {A B : \Type} (F A) (F B) : (F B)
  | return {A : \Type} A : F A
  | monad-left-id {A B : \Type} (a : A) (h : A -> F B) : (return a >>= h) = h a
  | monad-right-id {A : \Type} (m : F A) : (m >>= return) = m
  | monad-assoc {A B C : \Type} (m : F A) (g : A -> F B) (h : B -> F C) : (m >>= g >>= h) = (m >>= (\lam x => g x >>= h))

\data Maybe (A : \Type) | nothing | just A

\instance MaybeMonad : Monad Maybe
  | fmap {A B : \Type} (f : A -> B) : (Maybe A) -> Maybe B => \lam ma => \case ma \with {
    | nothing => nothing
    | just a => just (f a)
  }
  | fmap-id => {?}
  | fmap-comp => {?}
  | >>= {A B : \Type} (ma : Maybe A) (f : A -> Maybe B) : Maybe B => \case ma \with {
    | nothing => nothing
    | just a => \case f a \with {
      | nothing => nothing
      | just b => just b
    }
  }
  | return => just
  | monad-left-id => {?}
  | monad-right-id => {?}
  | monad-assoc => {?}

-- 6. Define instances for the class of monads for 'State' and 'State''.

\record State (S A : \Type)
  | state : S -> \Sigma S A

\data State' (S A : \Type)
  | state' (S -> \Sigma S A)
